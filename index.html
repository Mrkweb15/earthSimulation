<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Earth with Clouds</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
</head>
<body style="margin:0;">
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;

    const sunLight = new THREE.PointLight(0xffaa33, 2, 300);
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);

    const loader = new THREE.TextureLoader();
    const earthDay = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg');
    const earthNight = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_lights_2048.png');
    const moonTex = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg');
    const cloudTex = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png');


    const sun = new THREE.Mesh(
      new THREE.SphereGeometry(20, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0xffcc00 })
    );
    scene.add(sun);

    const earth = new THREE.Mesh(
      new THREE.SphereGeometry(5, 64, 64),
      new THREE.MeshStandardMaterial({
        map: earthDay,
        emissiveMap: earthNight,
        emissive: new THREE.Color(0xffffff),
        emissiveIntensity: 0.6
      })
    );
    scene.add(earth);

    // üå•Ô∏è Clouds
    const clouds = new THREE.Mesh(
    new THREE.SphereGeometry(5.1, 64, 64),
    new THREE.MeshLambertMaterial({
        map: cloudTex,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        side: THREE.DoubleSide
    })
    );
    scene.add(clouds);


    const moon = new THREE.Mesh(
      new THREE.SphereGeometry(1.2, 32, 32),
      new THREE.MeshStandardMaterial({ map: moonTex })
    );
    scene.add(moon);

    function createStars() {
      const geo = new THREE.BufferGeometry();
      const vertices = [];
      for (let i = 0; i < 10000; i++) {
        vertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
      }
      geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 })));
    }
    createStars();

    let earthAngle = 0;
    let moonAngle = 0;
    const earthRadius = 100;
    const moonRadius = 12;

    camera.position.set(0, 20, 150);
    controls.target.copy(earth.position);
    controls.update();

    // ========== ZOOM CAPTURE + LOCK SYSTEM ==========
    function captureZoomDistance() {
      const distance = camera.position.distanceTo(earth.position);
      const direction = new THREE.Vector3().subVectors(camera.position, earth.position).normalize();
      const newPos = direction.multiplyScalar(distance).add(earth.position);
      camera.position.copy(newPos);
      controls.update();
    }

    renderer.domElement.addEventListener('wheel', () => {
      controls.enableZoom = true;
      clearTimeout(window.zoomTimeout);
      window.zoomTimeout = setTimeout(() => {
        captureZoomDistance();
        controls.enableZoom = false;
      }, 200);
    });

    function animate() {
      requestAnimationFrame(animate);

      earth.rotation.y += 0.002;
      clouds.rotation.y += 0.0025;

      earthAngle += 0.002;
      earth.position.x = Math.cos(earthAngle) * earthRadius;
      earth.position.z = Math.sin(earthAngle) * earthRadius;

      clouds.position.copy(earth.position);


      moonAngle += 0.01;
      moon.position.x = earth.position.x + Math.cos(moonAngle) * moonRadius;
      moon.position.z = earth.position.z + Math.sin(moonAngle) * moonRadius;
      moon.position.y = earth.position.y + Math.sin(moonAngle) * 2;

      controls.target.copy(earth.position);
      controls.update();

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
